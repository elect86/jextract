/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package jextract

import de.undercouch.gradle.tasks.download.DownloadAction
import de.undercouch.gradle.tasks.download.DownloadExtension
import de.undercouch.gradle.tasks.download.VerifyAction
import de.undercouch.gradle.tasks.download.VerifyExtension
import org.gradle.api.*
import org.gradle.api.artifacts.dsl.DependencyHandler
import org.gradle.api.plugins.ApplicationPlugin
import org.gradle.api.plugins.ExtensionAware
import org.gradle.api.plugins.JavaApplication
import org.gradle.api.plugins.JavaPlugin
import org.gradle.api.tasks.SourceSet
import org.gradle.api.tasks.SourceSetContainer
import org.gradle.api.tasks.TaskProvider
import org.gradle.api.tasks.bundling.Jar
import org.gradle.api.tasks.compile.JavaCompile
import org.gradle.api.tasks.testing.Test
import org.gradle.kotlin.dsl.*
import java.net.URL
import java.util.*
import kotlin.collections.ArrayList

/**
 * A simple 'hello world' plugin.
 */
class JextractPlugin : Plugin<Project> {

    companion object {
        private val PROPERTY_JAVA_HOME = "javaHome"
    }

    override fun apply(target: Project) {

        target.plugins.apply("de.undercouch.download")

        // Create and register jextract task
        val jex = target.tasks.create<JextractTask>("jextract")

        target.tasks.register("setup panama jdk 17") {

            group = "build"

            doLast {
                fun getLinux(text: String, offset: Int = 0): String {
                    val index = text.indexOf("\"https://download.java.net/java/early_access/panama/", startIndex = offset) + 1 // drop first "
                    val url = text.substring(index, endIndex = text.indexOf("\">", startIndex = index))
                    val keys = listOf("openjdk", "17", "panama", "linux-x64", "bin")
                    return when {
                        keys.all { it in url } -> url
                        else -> getLinux(text, index)
                    }
                }

                lateinit var url: String
                target.extensions.getByName<DownloadExtension>("download").configure(
                    delegateClosureOf<DownloadAction> {
                        url = getLinux(URL("https://jdk.java.net/panama/").readText())
                        src(url)
                        downloadTaskDir(target.buildDir.resolve("tmp"))
                        dest(target.buildDir)
                        overwrite(false)
                        onlyIfModified(true)
                        useETag(true)
                    })

                val file = target.buildDir.resolve(url.substringAfterLast('/'))
                target.extensions.getByName<VerifyExtension>("verifyChecksum").configure(
                    delegateClosureOf<VerifyAction> {
                        src(file)
                        algorithm("SHA-256")
                        checksum(URL("$url.sha256").readText())
                    })

                val extractedDir = target.buildDir.resolve("jdk-17")
                if (!extractedDir.exists()) {
                    target.copy {
                        from(target.tarTree(target.resources.gzip(file)))
                        into(target.buildDir)
                    }

                    // we need to tell Gradle where to find our experimental panama jdk
                    val prop = target.file("gradle.properties")
                    val lines = prop.readLines() as ArrayList<String>
                    val pathIndex = lines.indexOfFirst { it.startsWith("org.gradle.java.installations.paths") }
                    val jdkPath = "${project.buildDir}/jdk-17"
                    var writeBack = true
                    if (pathIndex == -1)
                        lines += "# added by jextract plugin\norg.gradle.java.installations.paths=$jdkPath"
                    else if (jdkPath in lines[pathIndex])
                        writeBack = false // jdkPath already included
                    else
                        lines[pathIndex] = "# modified by jextract plugin\n${lines[pathIndex]},$jdkPath"

                    if (writeBack)
                        prop.writeText(lines.joinToString(separator = "\n"))
                }
            }
        }

        // Configure Java plugin if it was applied
        target.plugins.withType<JavaPlugin> {

            // To make the generated classes available for our code,
            // we need to add the output directory to the list of source directories
            target.sourceSets {
                main {
                    java.srcDirs += jex.outputDir.asFile.get()

                    // This is necessary since jextract generates a compiled class file containing constants
                    compileClasspath += target.files(jex.outputDir)
                    runtimeClasspath += target.files(jex.outputDir)
                }
            }

            // This is necessary in case we use class file mode
            target.dependencies.implementation(target.files(jex.outputDir))

            // Include all generated classes inside our jar archive
            target.jar {
                from(jex.outputDir) {
                    include("**/*.class")
                }
            }

            // We need to add the foreign module, so the compiler sees its classes
            target.withType<JavaCompile> {
                options.compilerArgs.add("--add-modules")
                options.compilerArgs.add("jdk.incubator.foreign")
            }
            target.test {
                jvmArgs.add("--enable-native-access=ALL-UNNAMED")
                jvmArgs.add("--add-modules")
                jvmArgs.add("jdk.incubator.foreign")
            }

            // The java compiler should only be invoked after jextract generated its source files
            target.compileJava { dependsOn(jex) }
        }

        // Configure application plugin if it was applied
        target.plugins.withType<ApplicationPlugin> {
            // We need to add the foreign module, so that the classes are visible at runtime
            target.application.applicationDefaultJvmArgs = target.application.applicationDefaultJvmArgs +
                    "--enable-native-access=ALL-UNNAMED" + "--add-modules" + "jdk.incubator.foreign"
        }
    }
}

fun Project.sourceSets(configure: Action<SourceSetContainer>) = (this as ExtensionAware).extensions.configure("sourceSets", configure)
val SourceSetContainer.main: NamedDomainObjectProvider<SourceSet> get() = named<SourceSet>("main")
operator fun <T> NamedDomainObjectProvider<T>.invoke(action: T.() -> Unit) = configure(action)
fun DependencyHandler.implementation(dependencyNotation: Any) = add("implementation", dependencyNotation)
val Project.jar get() = tasks.named<Jar>("jar")
val Project.compileJava: TaskProvider<JavaCompile> get() = tasks.named<JavaCompile>("compileJava")
inline fun <reified S : Task> Project.withType(noinline configuration: S.() -> Unit): DomainObjectCollection<in S> = tasks.withType(S::class.java, configuration)
val Project.test: TaskProvider<Test> get() = tasks.named<Test>("test")
val Project.application: JavaApplication get() = (this as ExtensionAware).extensions.getByName<JavaApplication>("application")